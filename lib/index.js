// Generated by CoffeeScript 1.9.2
var Gluon, StreamSplitter, child_process, events, root,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  slice = [].slice;

child_process = require("child_process");

StreamSplitter = require("stream-splitter");

events = require("events");

Gluon = (function(superClass) {
  extend(Gluon, superClass);

  function Gluon() {
    var args1, binary, ctx, env;
    ctx = arguments[0], env = arguments[1], binary = arguments[2], args1 = 4 <= arguments.length ? slice.call(arguments, 3) : [];
    this.ctx = ctx;
    this.env = env;
    this.binary = binary;
    this.args = args1;
    this.scripts = {};
    this.debugEnabled = false;
  }

  Gluon.prototype.start = function() {
    var e, k, localEnv, ref, ref1, v;
    this.debug("Starting gluon " + this.binary + " " + this.args);
    try {
      localEnv = {};
      ref = process.env;
      for (k in ref) {
        v = ref[k];
        localEnv[k] = v;
      }
      ref1 = this.env;
      for (k in ref1) {
        v = ref1[k];
        localEnv[k] = v;
      }
      this.proc = child_process.spawn(this.binary, this.args, {
        env: localEnv,
        stdio: ["pipe", "pipe", process.stderr]
      });
      this.stdoutLines = this.proc.stdout.pipe(StreamSplitter("\n"));
      this.stdoutLines.encoding = "utf8";
      this.stdoutLines.on("token", (function(_this) {
        return function(t) {
          return _this.read(t);
        };
      })(this));
      this.stdoutLines.on("done", (function(_this) {
        return function() {
          console.log("Gluon terminated");
          return _this.emit("done");
        };
      })(this));
      return this.stdoutLines.on("error", function(err) {
        return console.error("Error in gluon!", err);
      });
    } catch (_error) {
      e = _error;
      throw "Failed to start gluon process: " + e;
    }
  };

  Gluon.prototype.stop = function() {
    return this.proc.kill();
  };

  Gluon.prototype.read = function(token) {
    var e, err, event, out, ref, type;
    try {
      event = JSON.parse(token);
    } catch (_error) {
      e = _error;
      this.debug("Invalid JSON:", token);
      this.sendError(null, "invalid json: " + e);
      return;
    }
    type = event["type"];
    switch (type) {
      case "add":
        err = this.add(event["name"], event["script"]);
        break;
      case "call":
        ref = this.call(event["name"], event["arg"]), out = ref[0], err = ref[1];
        break;
      case "emit":
        err = this.emitEvent(event["name"]);
        break;
      default:
        err = "message type unknown: " + type;
    }
    if (err != null) {
      return this.sendError(event["id"], err);
    } else if (out != null) {
      return this.send({
        "id": event["id"],
        "type": "result",
        "msg": out
      });
    }
  };

  Gluon.prototype.call = function(name, arg) {
    var e, fn, result;
    fn = this.scripts[name];
    if (fn == null) {
      return [null, "no such function " + name];
    }
    try {
      result = fn(arg);
      return [result, null];
    } catch (_error) {
      e = _error;
      return [null, e];
    }
  };

  Gluon.prototype.emitEvent = function(name) {
    if (name == null) {
      return "no event provided to emit";
    }
    this.emit(name);
    return null;
  };

  Gluon.prototype.add = function(name, script) {
    var e, fn;
    if (name == null) {
      return "script name absent";
    } else if (name in this.scripts) {
      return "script " + name + " exists";
    }
    try {
      this.ctx[name] = null;
      fn = eval("(" + script + ")");
      this.scripts[name] = (function(_this) {
        return function() {
          var args;
          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          return fn.apply(null, [_this.ctx].concat(slice.call(args)));
        };
      })(this);
    } catch (_error) {
      e = _error;
      return "invalid script: " + e;
    }
    return this.debug("Added script: " + name);
  };

  Gluon.prototype.sendError = function(id, obj) {
    return this.send({
      "type": "error",
      "id": id,
      "msg": obj
    });
  };

  Gluon.prototype.send = function(obj) {
    return this.proc.stdin.write(JSON.stringify(obj) + "\n");
  };

  Gluon.prototype.debug = function() {
    var objs;
    objs = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    if (this.debugEnabled) {
      return console.log.apply(console, objs);
    }
  };

  return Gluon;

})(events.EventEmitter);

root = typeof exports !== "undefined" && exports !== null ? exports : window;

root.Gluon = Gluon;
