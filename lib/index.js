// Generated by CoffeeScript 1.9.2
var Gluon, StreamSplitter, child_process, events, getProp, root,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  slice = [].slice,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

child_process = require("child_process");

StreamSplitter = require("stream-splitter");

events = require("events");

getProp = function(source, objName) {
  var obj;
  obj = source[objName];
  if (obj == null) {
    throw new Error(objName + " not found");
  }
  return obj;
};

Gluon = (function(superClass) {
  extend(Gluon, superClass);

  function Gluon() {
    var args1, binary, ctx, env, gl, key, val;
    ctx = arguments[0], env = arguments[1], binary = arguments[2], args1 = 4 <= arguments.length ? slice.call(arguments, 3) : [];
    this.ctx = ctx;
    this.env = env;
    this.binary = binary;
    this.args = args1;
    this.scripts = {};
    this.debugEnabled = false;
    this.callbackCtr = 0;
    gl = {
      'module': module,
      'process': process,
      'global': global,
      'console': console,
      '__dirname': __dirname,
      '__filename': __filename
    };
    for (key in gl) {
      val = gl[key];
      if (indexOf.call(this.ctx, key) < 0) {
        this.ctx[key] = val;
      }
    }
  }

  Gluon.prototype.start = function() {
    var e, k, localEnv, ref, ref1, v;
    this.debug("Starting gluon " + this.binary + " " + this.args);
    try {
      localEnv = {};
      ref = process.env;
      for (k in ref) {
        v = ref[k];
        localEnv[k] = v;
      }
      ref1 = this.env;
      for (k in ref1) {
        v = ref1[k];
        localEnv[k] = v;
      }
      this.proc = child_process.spawn(this.binary, this.args, {
        env: localEnv,
        stdio: ["pipe", "pipe", process.stderr]
      });
      this.stdoutLines = this.proc.stdout.pipe(StreamSplitter("\n"));
      this.stdoutLines.encoding = "utf8";
      this.stdoutLines.on("token", (function(_this) {
        return function(t) {
          return _this.read(t);
        };
      })(this));
      this.stdoutLines.on("done", (function(_this) {
        return function() {
          console.log("Gluon terminated");
          return _this.emit("done");
        };
      })(this));
      return this.stdoutLines.on("error", function(err) {
        return console.error("Error in gluon!", err);
      });
    } catch (_error) {
      e = _error;
      throw "Failed to start gluon process: " + e;
    }
  };

  Gluon.prototype.stop = function() {
    return this.proc.kill();
  };

  Gluon.prototype.read = function(token) {
    var e, event, id, out, type;
    if (token.charAt(0) !== '{') {
      process.stdout.write(token);
      process.stdout.write('\n');
      return;
    }
    id = null;
    try {
      event = JSON.parse(token);
      type = event["type"];
      id = event["id"];
      switch (type) {
        case "add":
          this.add(event["name"], event["script"]);
          break;
        case "attr":
          out = this.attr(event["obj"], event["name"], event["save"]);
          break;
        case "fn":
          out = this.fn(event["obj"], event["name"], event["save"], event["arg"], event["new"]);
          break;
        case "free":
          this.free(event["obj"]);
          break;
        case "call":
          out = this.call(event["name"], event["arg"]);
          break;
        case "emit":
          this.emitEvent(event["name"]);
          break;
        default:
          throw new Error("message type unknown: " + type);
      }
      return this.send({
        "id": id,
        "type": "ok",
        "msg": out
      });
    } catch (_error) {
      e = _error;
      return this.sendError(id, e);
    }
  };

  Gluon.prototype.free = function(objRef) {
    return delete this.ctx[objRef];
  };

  Gluon.prototype.saveOrReturn = function(save, result) {
    if ((save != null) === "void") {
      return null;
    } else if (save != null) {
      this.ctx[save] = result;
      return null;
    }
    return result;
  };

  Gluon.prototype.makeArg = function(value, objectRef, callbackRef) {
    if ((callbackRef != null) && callbackRef.length > 0) {
      return (function(_this) {
        return function() {
          var arg, args, i, j, len, notifyArgs, rest, storedId;
          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          notifyArgs = [callbackRef[0]];
          rest = callbackRef.slice(1);
          if (args.length !== rest.length) {
            _this.sendError(null, "expected " + rest.length + " args but received " + args.length + " for " + callbackRef[0]);
            return;
          }
          for (i = j = 0, len = rest.length; j < len; i = ++j) {
            arg = rest[i];
            if ((arg == null) || arg === "") {
              notifyArgs.push(args[i]);
            } else {
              _this.callbackCtr++;
              storedId = arg + "/" + _this.callbackCtr;
              _this.ctx[storedId] = args[i];
              notifyArgs.push(storedId);
            }
          }
          return _this.notify.apply(_this, notifyArgs);
        };
      })(this);
    } else if (objectRef != null) {
      return getProp(this.ctx, objectRef);
    } else {
      return value;
    }
  };

  Gluon.prototype.fn = function(objName, name, save, args, isConstructor) {
    var arg, f, filtered, j, len, obj, result;
    obj = getProp(this.ctx, objName);
    f = getProp(obj, name);
    filtered = [];
    if (args != null) {
      for (j = 0, len = args.length; j < len; j++) {
        arg = args[j];
        filtered.push(this.makeArg.apply(this, arg));
      }
    }
    if ((isConstructor != null) && isConstructor) {
      result = new (Function.prototype.bind.apply(f, filtered));
    } else {
      result = f.apply(obj, filtered);
    }
    return this.saveOrReturn(save, result);
  };

  Gluon.prototype.attr = function(objName, name, save) {
    return this.saveOrReturn(save, getProp(getProp(this.ctx, objName), name));
  };

  Gluon.prototype.call = function(name, arg) {
    var fn, result;
    fn = this.scripts[name];
    if (fn == null) {
      throw new Error("no such function " + name);
    }
    return result = fn(arg);
  };

  Gluon.prototype.emitEvent = function(name) {
    if (name == null) {
      throw new Error("no event provided to emit");
    }
    this.emit(name);
    return null;
  };

  Gluon.prototype.add = function(name, script) {
    var e, fn, notify;
    if (name == null) {
      throw new Error("script name absent");
    } else if (name in this.scripts) {
      throw new Error("script " + name + " exists");
    }
    try {
      this.ctx[name] = null;
      fn = eval("(" + script + ")");
      notify = (function(_this) {
        return function(name, arg) {
          return _this.notify(name, arg);
        };
      })(this);
      this.scripts[name] = (function(_this) {
        return function() {
          var args;
          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          return fn.apply(null, [notify, _this.ctx].concat(slice.call(args)));
        };
      })(this);
    } catch (_error) {
      e = _error;
      throw new Error("invalid script: " + e);
    }
    return this.debug("Added script: " + name);
  };

  Gluon.prototype.sendError = function(id, obj) {
    var msg;
    if (obj instanceof Error) {
      msg = obj.stack;
    } else {
      msg = obj;
    }
    return this.send({
      "type": "error",
      "id": id,
      "msg": msg
    });
  };

  Gluon.prototype.notify = function() {
    var arg, name;
    name = arguments[0], arg = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    return this.send({
      "type": "notify",
      "name": name,
      "arg": arg
    });
  };

  Gluon.prototype.send = function(obj) {
    var e, str;
    try {
      str = JSON.stringify(obj);
      return this.proc.stdin.write(str + "\n");
    } catch (_error) {
      e = _error;
      console.error("error sending", obj, e.stack);
      throw e;
    }
  };

  Gluon.prototype.debug = function() {
    var objs;
    objs = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    if (this.debugEnabled) {
      return console.log.apply(console, objs);
    }
  };

  return Gluon;

})(events.EventEmitter);

root = typeof exports !== "undefined" && exports !== null ? exports : window;

root.Gluon = Gluon;
